# 자료구조 모아보기

## [1] 변수와 리스트, 그리고 For문을 보는 관점

`변수`: 자료가 담기는 하나의 Box

```
변수의 이름짓기는 매우 중요합니다. 이름을 잘 지어두면, 특정 목적을 하는 변수임을 나타낼 수도 있으며, 해당 변수가 어떤 정보를 담고있는지 한 눈에 파악하기 쉽기 때문입니다.
```

```
# <변수의 할당>
# 일반적으로 = (할당연산자) 를 사용하여 할당합니다.
a = 3

# 특정 상태를 체크했음을 나타내는 변수는 관례적으로 flag 라고 이름 짓습니다.
# 마치 결승선에 들어오면 깃발을 올리는 것처럼 -> 특정 조건이 충족되었을때 True 가 됩니다.
flag = False
```

1. 만약 현실 생활의 정보가 있고, 이걸 담아 보겠다고 마음먹어보죠.

   이름이 ‘멀캠이’인 사람이 있는데 → 나이는 5살이고, 사는곳은 역삼역이라고 합시다.

   그럼 우선적으로 생각나는건, 이렇게 변수(박스) 하나하나에 담을 수 있지 않을까요?

   ```
   name = '멀캠이'
   age = 5
   address = '역삼'
   ```

   하지만, 경우에 따라서는 이와 같은 방식이 비효율적일 수 있습니다.

   

2. 다른 방법은, 딕셔너리 를 사용해 하나의 변수에  위의 정보들을 모두 포함할 수도 있습니다.

   딕셔너리는 key, value 로 이루어져 있습니다. 사전에 해당 단어를 키값으로 찾으면, 해당 키값이 해당하는 뜻을 알 수 있는 것처럼 → 1 : 1 대응으로 연결되어 있습니다.

   이후에 알고리즘 문제에서는, 2개의 데이터셋 사이의 `링크` 를 주고 싶을때 의도적으로 딕셔너리를 활용할 수 있습니다.

```
mulcam_info = {'name':'멀캠이', 'age':5, 'address':'역삼'}
```



`리스트`: 자료들을 담아두는 알약통 (가끔은 한 칸에 많은 자료를 넣을 수도 있다.)

리스트는 기본적으로 다음과 같이 선언 합니다. 지정은 `인덱스` 로 가능합니다.

```
# 2가지 방법이 존재합니다.
infos = []
infos = list()

# 이렇게도 가능하지 않을까?
mulcam_infos = ['멀캠이', 5, '역삼']
```

하지만 이렇게 구조화 하는 것보다는, 아까 딕셔너리 방식이 나을 것 같네요.

만약 사람이 여러명이라고 하면 다른 접근 방식을 취해야 합니다.

→ 여기에 역삼멀캠이와, 선릉멀캠이가 있습니다.

현실 정보 : 역삼 멀캠이는 5살이고 역삼에 살며, 선릉 멀캠이는 3살이며 선릉에 있습니다.

```
mulcam_infos = [{'name':'역삼멀캠이', 'age':5, 'address':'역삼'}, 
				{'name':'선릉멀캠이', 'age':3, 'address':'선릉'}]
```

> ***결국 중요한 것은 List를 쓰느냐 Dictionary를 쓰느냐, 혹은 set을 쓰느냐와 관계 없이 주어진 정보를 내가 활용하기 좋게끔 어떻게 구조화 할 수 있는가가 본질입니다.***



`For 문`: 자료를 넘나들어 이동하는 방법

```
# 0 부터 10 까지 range 함수를 이용해 출력할 수 있습니다.
for i in range(11):
    print(i)

# 포문은 뽑아져 나온 상태까지를 시간을 얼린다고 치면, 그 뽑아져 나온 사실을 전제로 받아들이고,
# 그 전제 하에서 아래 영역의 로직이 돌아가게 됩니다.

# 단순히 반복적으로 '돌기만' 하는데 특정 로직을 반복하게끔 할 수도 있습니다.
# 이 경우 i 는 뽑아져 나오는데, 딱히 쓰진 않습니다.
for i in range(11):
    print('안녕하세요')

# 관례적으로 단순히 돌돌 돌기만 할거면 _ (언더바)를 쓰는 사람도 있습니다.
# 이 경우도 _ 에 뭐가 담기긴 하는데, 쓰진 않습니다.
for _ in range(11):
		print('안녕하세요')

# 리스트는 인덱스로 지정할 수 있으므로 우선 cards 리스트의 길이를 잰 후, 그 길이까지의 인덱스를 지정해서 출력할 수 있으며 range 함수를 활용하게 됩니다.
cards = [8, 3, 2, 8, 1, 8]

# len(cards) 까지는 6 이고, 결국 range(6)과 같은데, 
# 0 이상 6 '미만' 이므로 0~5 인덱스 범위를 지정하게 되어 모두 순회할 수 있다.
for idx in range(len(cards)):
    print(cards[idx])
```

> ***

> ***For 문은 단순히 반복만 하는게 아니라 반복하는 성질을 이용하여 리스트 위에 화살표(포인터)를 들이미는 식으로 리스트 안에 자료들을 하나하나 살펴볼 수 있다는 점을 이해하는 것이 중요***

---

## [2] List 집중 탐구

![image-20220315100126915](C:\Users\vjkim\AppData\Roaming\Typora\typora-user-images\image-20220315100126915.png)

```
# 전력 회사의 데이터
houses = [0, 1, 0, 0]

# 이렇게도 표현할 수 있습니다
houses = [False, True, False, False]
```

만약 이런 상황이면, 4개면 다행이겠지만 집이 한 1000개쯤 있으면 사람이 이걸 일일히 확인하기 어려울 겁니다.

그래서 아까 설명한 것처럼, For 문을 이용해서 자료를 `체크` 하고 넘어갈건데, 여기서 다양한 방법을 시도해보도록 할게요.

파이썬에서 찾기만 할 거라면, 이런 방법으로도 찾을 수는 있습니다. (containment test → `in`)

```
# 10개 가구의 실시간 데이터
houses = [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]

if 1 in houses:
    print('전력을 차단하지 말아주세요')
    
# 10개 가구의 실시간 데이터 
houses = [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]

# 우선 for 문으로 하나하나 돌면서, 1이 있는지를 찾을 수 있습니다.
for house in houses:
    if house == 1:
        print('전력을 차단하지 말아주세요')

# 이렇게 써도 됩니다. 1은 True 라고 평가되기 때문이죠. (0은 False 라고 평가됩니다.)
for house in houses:
    if house:
        print('전력을 차단하지 말아주세요')
```

그런데, 만약 실시간 데이터를 살펴보니 아무도 전력을 사용하지 않는 다음과 같은 상황이라면

위의 코드로는 설비 작업을 진행할지 말지에 대한 정보를 결국에는 알 수 없습니다.

그러면 이런 방법을 사용할 수 있습니다.

```
houses = [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]

# 기본적으로 준비가 됐다고 생각을 하고,
ready = True 

for house in houses:  # 하나씩 돌면서 각각의 집들을 체크해볼건데,
    if house == 1: # 불켜진 집을 하.나.라.도! 발견 했다면?
        ready = False  # 준비가 되지 않았다고 하자!
        
print(ready) # ready 여부를 출력해보자
```

그런데 여기서 의문이 생기죠, 찾은 이후에는 꼭 다 돌필요 없는거 아닌가?`효율성` 에 대한 고민입니다.

```
houses = [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]

# 기초 자료가 이렇게 되어있다면, 2번 인덱스의 (리스트에서 3번째의) 1을 찾은 이후로는, 그 이후로 더 볼 필요 조차 없습니다. → break 를 활용하여 불 켜진 집을 찾는 즉시 포문을 파괴하면, 리스트가 길면 길수록 더 효율적인 코드를 작성할 수 있습니다.

ready = True

for house in houses:
    if house == 1:
        ready = False
        break  # 브레이크!!!

print(ready)
```

```
# for - else구문을 사용한 로직
houses = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

for house in houses:
    if house == 1:
        print('전력을 차단하지 말아주세요')
        break
else:  # 여기서 else 는 위에서 단 한번이라도 break 가 걸리지 않을 경우만 발동합니다.
    print('작업을 시작해도 될 것 같아요')
```



---

> 실습 예제 1 = min(), max() 함수 직접 구현해보기

```
# 현재 주어진 숫자들에 대한 정보는 다음과 같습니다. 모든 숫자는 0 이상 100미만의 정수 입니다.
nums = [1, 5 ,77, 26, 33, 2, 6, 16, 55]

# 일반적으로 max, min 함수를 쓰면 바로 최댓값과 최솟값을 구해 줍니다.
print(max(nums))
print(min(nums))
```

```
# max 구현
nums = [1, 5 ,77, 26, 33, 2, 6, 16, 55]

max_num = -1 # 비교할 수 있는 가장 작은 숫자

for num in nums:
    if num > max_num: # num(1)이 max_num(-1)보다 크면 
        max_num = num  # max_num(1)로 변환

print(max_num) # 77보다 큰 수가 없으므로 max_num은 77이 되어 출력
```

```
# min 구현
nums = [1, 5 ,77, 26, 33, 2, 6, 16, 55]

min_num = 101  # 비교할 수 있는 가장 큰 숫자

for num in nums:
    if num < min_num: # num(1)이 max_num(101)보다 작으면 
        min_num = num # max_num(1)로 변환

print(min_num)  # 1보다 작은 수가 없으므로 max_num은 1이 되어 출력
```



---

> 실습 예제2 = 베이비진 게임

![image-20220315102008197](https://user-images.githubusercontent.com/100325988/158344806-ab5a7c26-4779-4e57-8eda-219af29d8b6d.png)

***Triplet 여부 판단하기***

```
# 내가 받은 카드 목록
cards = [8, 3, 2, 8, 1, 8]
```

```
# 길이가 10개짜리 리스트 생성
a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

# for문을 통해 card에서 카드 숫자가 나올 때마다 a리스트 각각에 숫자를 증가시키기
for _ in cards:
    a[_-1] = a[_-1] + 1  # 8이 나오면 인덱싱을 통해 8자리에 +1을 시켜줌
    if a[_-1] >= 3:      # 숫자가 3 이상이라면 트리플렛!
        print("트리플렛입니다.")
```

*** Run 여부 판단하기***

```
# 내가 받은 카드 목록
cards = [8, 3, 2, 8, 1, 8]

# 길이가 10개짜리 리스트 생성
a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

# for문을 통해 card에서 카드 숫자가 나올 때마다 a리스트 각각에 숫자를 증가시키기
for _ in cards:
    a[_-1] = a[_-1] + 1  # 8이 나오면 인덱싱을 통해 8자리에 +1을 시켜줌
    if a[_-1] >= 1 and a[_] >= 1 and a[_+1] >= 1:
        print("Run입니다.")
        break
```



---

## [3] 문자열(String) 탐구하기

> 문제 상황: 회원가입 아이디 기입에서 이메일 형식이 자꾸 보임

```
# 결국 받아진 정보가 다음과 같다면?
customers = ['alex@hphk.kr', 'kyle', 'ted@gmail.com', 'paul@gmail.com']

# 이걸 이렇게 만들고 싶은데...
customer_ids = ['alex', 'kyle', 'ted', 'paul']
```

```
email = 'alex@hphk.kr'
splitted_list = email.split('@')
print(splitted_list) # ['alex', 'hphk.kr']

# 그러면 아예 처음거를 [0] 인덱스 지정해서 가져오면?
real_id = email.split('@')[0]
print(real_id) # alex
```

```
email = 'alex@hphk.kr'

real_id = ''  # 일단 id 를 모아줄 변수를 하나 설정하고

for letter in email:  # 문자열을 하나씩 돌아볼건데,
    if letter != '@':  # 골뱅이가 아닌 경우에만
        real_id += letter  # 아까 변수에 모아주고
    else:  # 골뱅이를 발견하는 순간 
        break  # 포문을 파괴하자!

print(real_id)
```

